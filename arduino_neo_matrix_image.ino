
#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>
int lng = 100;//long delay
int sht = 50;//short delay
const int sampleWindow = 50; // Sample window width in mS (50 mS = 20Hz)
unsigned int sample;

// Which pin on the Arduino is connected to the NeoPixels?
#define PIN 3

// Max is 255, 32 is a conservative value to not overload
// a USB power supply (500mA) for 12x12 pixels.
#define BRIGHTNESS 96

// Define matrix width and height.
#define mw 8
#define mh 8

#define LED_BLACK    0

int counter = 0;
int bilderanzahl = 0;

// When we setup the NeoPixel library, we tell it how many pixels, and which pin to use to send signals.
// Note that for older NeoPixel strips you might need to change the third parameter--see the strandtest
// example for more information on possible values.
Adafruit_NeoMatrix *matrix = new Adafruit_NeoMatrix(mw, mh, PIN,
    NEO_MATRIX_TOP     + NEO_MATRIX_LEFT +
    NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG,
    NEO_GRB            + NEO_KHZ800);
    
static const uint16_t PROGMEM
// These bitmaps were written for a backend that only supported
// 4 bits per color with Blue/Green/Red ordering while neomatrix
// uses native 565 color mapping as RGB.
// I'm leaving the arrays as is because it's easier to read
// which color is what when separated on a 4bit boundary
// The demo code will modify the arrays at runtime to be compatible
// with the neomatrix color ordering and bit depth.


RGB_bmp1[][64] = {

//Mario 1
{
0x000,  0x000,  0xFF9900,  0x50F,  0x50F,  0x50F,  0xEEF,  0x000,
0x50F,  0x50F,  0x6699CC,  0x50F,  0x50F,  0x000,  0x000,  0x000,
0x000,  0x000,  0x35A,  0xACF,  0x35A,  0x000,  0xACF,  0x000,
0xACF,  0x35A,  0x35A,  0xACF,  0xACF,  0x35A,  0x000,  0x000,
0x000,  0x000,  0x000,  0x35A,  0xACF,  0xACF,  0xACF,  0x000,
0x000,  0x0AF,  0xFA2,  0xFA2,  0x2FF,  0x50F,  0x50F,  0x000,
0xEEF,  0x000,  0xFA2,  0xFA2,  0xFA2,  0xFA2,  0x532,  0x978,
0x000,  0x527,  0x000,  0x000,  0x000,  0x35A,  0x000,  0x000,

},

//Mario 2
RGB_bmp2[][64] ={
  0x000,  0x000,  0x000,  0x50F,  0x50F,  0x50F,  0xEEF,  0x000,
0x50F,  0x50F,  0x50F,  0x50F,  0x50F,  0x000,  0x000,  0x000,
0x000,  0x000,  0x35A,  0xACF,  0x35A,  0x000,  0xACF,  0x000,
0xACF,  0x35A,  0x35A,  0xACF,  0xACF,  0x35A,  0x000,  0x000,
0x000,  0x000,  0x000,  0x35A,  0xACF,  0xACF,  0xACF,  0x000,
0x000,  0x532,  0xFA2,  0x2FF,  0x50F,  0x50F,  0x000,  0x000,
0x000,  0x000,  0x50F,  0xEEF,  0xFA2,  0xFA2,  0x532,  0x000,
0x000,  0x000,  0x527,  0x35A,  0x35A,  0x000,  0x000,  0x000,

};

//Mario 3
RGB_bmp3[][64] ={

0x000,  0x000,  0x000,  0x50F,  0x50F,  0xEEF,  0x50F,  0x000,
0x50F,  0x50F,  0x50F,  0x50F,  0x50F,  0x000,  0x000,  0x000,
0x000,  0x000,  0xACF,  0x35A,  0x000,  0xACF,  0x000,  0x000,
0x35A,  0xACF,  0x35A,  0x35A,  0xACF,  0xACF,  0x000,  0x000,
0x000,  0x000,  0x000,  0xACF,  0xACF,  0xACF,  0xACF,  0x000,
0x000,  0x0AF,  0xFA2,  0xFA2,  0x2FF,  0x50F,  0x50F,  0x000,
0xEEF,  0x000,  0xFA2,  0xFA2,  0xFA2,  0xFA2,  0x532,  0x978,
0x000,  0x000,  0x35A,  0x000,  0x000,  0x527,  0x000,  0x000,

};
//Mario 4
RGB_bmp4[][64] ={

0x000,  0x000,  0x000,  0x50F,  0x50F,  0xEEF,  0x50F,  0x000,
0x50F,  0x50F,  0x50F,  0x50F,  0x50F,  0x000,  0x000,  0x000,
0x000,  0x000,  0xACF,  0x35A,  0x000,  0xACF,  0x000,  0x000,
0x35A,  0xACF,  0x35A,  0x35A,  0xACF,  0xACF,  0x000,  0x000,
0x000,  0x50F,  0x50F,  0xACF,  0xACF,  0xACF,  0xACF,  0x000,
0xEEF,  0x0AF,  0xFA2,  0xFA2,  0x2FF,  0x50F,  0x000,  0xEEF,
0x000,  0x527,  0xFA2,  0xFA2,  0xFA2,  0xFA2,  0x532,  0x000,
0x000,  0x35A,  0x000,  0x000,  0x000,  0x000,  0x000,  0x000,

};





//Hertz 1
RGB_bmp5[][64] ={
0x000,  0x0BF,  0x0BF,  0x000,  0x000,  0x0BF,  0x0BF,  0x000,
0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,
0x0BF,  0x0BF,  0x0BF,  0x00F,  0x0BF,  0x0BF,  0x0BF,  0x0BF,
0x0BF,  0x0BF,  0x0BF,  0x00F,  0x00F,  0x00F,  0x00F,  0x0BF,
0x0BF,  0x0BF,  0x0BF,  0x00F,  0x0BF,  0x0BF,  0x0BF,  0x0BF,
0x000,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x000,
0x000,  0x000,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x000,  0x000,
0x000,  0x000,  0x000,  0x0BF,  0x0BF,  0x000,  0x000,  0x000,
}
;

//Hertz 2
RGB_bmp6[][64] ={

  0x000,  0x0BF,  0x0BF,  0x000,  0x000,  0x0BF,  0x0BF,  0x000,
0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,
0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x00F,  0x0BF,  0x0BF,  0x0BF,
0x0BF,  0x0BF,  0x00F,  0x00F,  0x00F,  0x00F,  0x0BF,  0x0BF,
0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x00F,  0x0BF,  0x0BF,  0x0BF,
0x000,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x000,
0x000,  0x000,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x000,  0x000,
0x000,  0x000,  0x000,  0x0BF,  0x0BF,  0x000,  0x000,  0x000,

}
;

//Hertz 3

{

  0x000,  0x0BF,  0x0BF,  0x000,  0x000,  0x0BF,  0x0BF,  0x000,
0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,
0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x5A0,  0x0BF,  0x0BF,
0x0BF,  0x5A0,  0x5A0,  0x5A0,  0x5A0,  0x0BF,  0x0BF,  0x0BF,
0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x5A0,  0x0BF,  0x0BF,
0x000,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x000,
0x000,  0x000,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x000,  0x000,
0x000,  0x000,  0x000,  0x0BF,  0x0BF,  0x000,  0x000,  0x000,

},

//Hertz 4
{

  0x000,  0x0BF,  0x0BF,  0x000,  0x000,  0x0BF,  0x0BF,  0x000,
0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,
0x0BF,  0x0BF,  0x33FF33,  0x33FF33,  0x33FF33,  0x33FF33,  0xEA0,  0x0BF,
0xEA0,  0xEA0,  0x33FF33,  0x33FF33,  0x33FF33,  0x33FF33,  0xBBE,  0x0BF,
0x0BF,  0xBBE,  0x0BF,  0x33FF33,0x33FF33,  0x0BF,  0xEA0,  0x0BF,
0x000,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x000,
0x000,  0x000,  0x0BF,  0x0BF,  0x0BF,  0x0BF,  0x000,  0x000,
0x000,  0x000,  0x000,  0x0BF,  0x0BF,  0x000,  0x000,  0x000,

};

//smiley
RGB_bmp1[][64] ={

0x000,  0x000,  0x000,  0x000,  0x000,  0x000,  0x000,  0x000,
0x000,  0x000,  0x07F,  0x00F,  0x00F,  0x07F,  0x000,  0x000,
0x000,  0x0EF,  0x0FF,  0x07F,  0x07F,  0x0EF,  0x0FF,  0x000,
0x000,  0x0F3,  0x000,  0x0DF,  0x0DF,  0x000,  0x0F3,  0x000,
0x000,  0xFB0,  0x0F3,  0x0FA,  0x0FA,  0x0F3,  0xFB0,  0x000,
0x000,  0xF15,  0xFE0,  0x000,  0x000,  0xFE0,  0xF15,  0x000,
0x000,  0x000,  0xF15,  0xFB0,  0xFB0,  0xF15,  0x000,  0x000,
0x000,  0x000,  0x000,  0x000,  0x000,  0x000,  0x000,  0x000,


}
;

//Melone
RGB_bmp1[][64] ={
  0x000,  0x000,  0x000,  0x000,  0x000,  0x00F,  0x00F,  0x5A0,
0x5A0,  0x5C9,  0x000,  0x00F,  0x000,  0x000,  0x000,  0x000,
0x000,  0x000,  0x000,  0x000,  0x00F,  0x00F,  0x5C9,  0x5A0,
0x5A0,  0x5C9,  0xBDF,  0x00F,  0x00F,  0x000,  0x000,  0x000,
0x000,  0x00F,  0x00F,  0x00F,  0x00F,  0xBDF,  0x5C9,  0x000,
0x000,  0x5A0,  0x5C9,  0xBDF,  0xBDF,  0x00F,  0x000,  0x00F,
0x00F,  0x5C9,  0x5C9,  0x5C9,  0x5C9,  0x5A0,  0x000,  0x000,
0x000,  0x000,  0x000,  0x000,  0x5A0,  0x5A0,  0x5A0,  0x5A0,

}
;



void display_rgbBitmap(uint8_t bmp_num) {
  static uint16_t bmx, bmy;

  fixdrawRGBBitmap(bmx, bmy, RGB_bmp[bmp_num], 8, 8);
  bmx += 8;
  if (bmx >= mw) bmx = 0;
  if (!bmx) bmy += 8;
  if (bmy >= mh) bmy = 0;
  matrix->show();
}

// Convert a BGR 4/4/4 bitmap to RGB 5/6/5 used by Adafruit_GFX
void fixdrawRGBBitmap(int16_t x, int16_t y, const uint16_t *bitmap, int16_t w, int16_t h) {
  uint16_t RGB_bmp_fixed[w * h];
  for (uint16_t pixel = 0; pixel < w * h; pixel++) {
    uint8_t r, g, b;
    uint16_t color = pgm_read_word(bitmap + pixel);

    //Serial.print(color, HEX);
    b = (color & 0xF00) >> 8;
    g = (color & 0x0F0) >> 4;
    r = color & 0x00F;
    //Serial.print(" ");
    //Serial.print(b);
    //Serial.print("/");
    //Serial.print(g);
    //Serial.print("/");
    //Serial.print(r);
    //Serial.print(" -> ");
    // expand from 4/4/4 bits per color to 5/6/5
    b = map(b, 0, 15, 0, 31);
    g = map(g, 0, 15, 0, 63);
    r = map(r, 0, 15, 0, 31);
    //Serial.print(r);
    //Serial.print("/");
    //Serial.print(g);
    //Serial.print("/");
    //Serial.print(b);
    RGB_bmp_fixed[pixel] = (r << 11) + (g << 5) + b;
   // Serial.print(" -> ");
    //Serial.print(pixel);
    //Serial.print(" -> ");
    //Serial.println(RGB_bmp_fixed[pixel], HEX);
  }
  matrix->drawRGBBitmap(x, y, RGB_bmp_fixed, w, h);
}

void setup() {
  Serial.begin(115200);

  matrix->begin();
  matrix->setTextWrap(false);
  matrix->setBrightness(BRIGHTNESS);
  // Test full bright of all LEDs. If brightness is too high
  // for your current limit (i.e. USB), decrease it.
  //matrix->fillScreen(LED_WHITE_HIGH);
  //matrix->show();
  //delay(1000);
  matrix->clear();
  bilderanzahl=(sizeof(RGB_bmp) / sizeof(RGB_bmp[0]));
  Serial.print("Anzahl Bilder: ");
  Serial.println(bilderanzahl);
}



void loop() {

  // clear the screen after X bitmaps have been displayed and we
  // loop back to the top left corner
  // 8x8 => 1, 16x8 => 2, 17x9 => 6
  static uint8_t pixmap_count = ((mw + 7) / 8) * ((mh + 7) / 8);
  // Cycle through red, green, blue, display 2 checkered patterns
  // useful to debug some screen types and alignment.

  Serial.print("Screen pixmap capacity: ");
  Serial.println(pixmap_count);

  display_rgbBitmap(counter++);
  delay(500);

  if (counter >=bilderanzahl){
    counter = 0;
  }

  Serial.println ("----------------------------------------------------------------");
  //delay(1000);
  unsigned long startMillis = millis(); // Start of sample window
  unsigned int peakToPeak = 0;   // peak-to-peak level

  unsigned int signalMax = 0;
  unsigned int signalMin = 1024;

  // collect data for 50 mS
  while (millis() - startMillis < sampleWindow)
  {
    //open while loop
    sample = analogRead(0);
    if (sample < 1024)  // toss out spurious readings
    {
      //open 1st if loop in while
      if (sample > signalMax)
      {
        //open 2nd if
        signalMax = sample;  // save just the max levels
      }//close 2nd if
      else if (sample < signalMin)
      {
        //open 3rd if
        signalMin = sample;  // save just the min levels
      }//close 3rd if
    }//close 1st if
  }//close while loop
  peakToPeak = signalMax - signalMin;  // max - min = peak-peak amplitude
  double volts = (peakToPeak * 3.3) / 1024;  // convert to volts

//section below maps the signal from the microphone on to 12 options for LED effects

  int sound = (volts * 10);

  int soundLevel = map(sound, 1, 10, 0, 11);
  Serial.print("The volt level is  ");
  Serial.println(volts);//for debugging



      
      
  
  

}

